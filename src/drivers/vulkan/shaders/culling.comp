#version 450

#define PI 3.14159265359

struct world_data {
    mat4 transform;
    vec4 bsphere;
};

struct command_data {
	uint index_count;
	uint instance_count;
	uint first_index;
	int vertex_offset;
	uint first_instance;
};

layout (std140, set = 0, binding = 0) uniform main_data {
    mat4 proj;
    mat4 view;
    mat4 proj_view;
    mat4 inv_proj_view;
    vec4 camera_position;
    vec4 camera_frustum;
    uvec4 additional_info;
} u_main;

layout (std430, set = 0, binding = 1) readonly buffer world_buffer {
    world_data data[];
} u_world;


layout (std430, set = 1, binding = 0) readonly buffer draw_buffer {
    command_data data[];
} u_draw;

layout (std430, set = 1, binding = 1) writeonly buffer draw_output_buffer {
    command_data data[];
} u_draw_output;

layout (set = 1, binding = 2) uniform sampler2D u_depth_pyramid;

layout (std430, set = 1, binding = 3) readonly buffer occlusion_buffer {
    uint data[];
} u_occlusion;

shared vec3 s_camera_data;

layout(local_size_x = 16, local_size_y = 1, local_size_z = 1) in;

// 2D Polyhedral Bounds of a Clipped, Perspective-Projected 3D Sphere. Michael Mara, Morgan McGuire. 2013
bool project_sphere(vec3 C, float r, float znear, float P00, float P11, out vec4 aabb)
{
	if (C.z < r + znear)
		return false;

	vec2 cx = -C.xz;
	vec2 vx = vec2(sqrt(dot(cx, cx) - r * r), r);
	vec2 minx = mat2(vx.x, vx.y, -vx.y, vx.x) * cx;
	vec2 maxx = mat2(vx.x, -vx.y, vx.y, vx.x) * cx;

	vec2 cy = -C.yz;
	vec2 vy = vec2(sqrt(dot(cy, cy) - r * r), r);
	vec2 miny = mat2(vy.x, vy.y, -vy.y, vy.x) * cy;
	vec2 maxy = mat2(vy.x, -vy.y, vy.y, vy.x) * cy;

	aabb = vec4(minx.x / minx.y * P00, miny.x / miny.y * P11, maxx.x / maxx.y * P00, maxy.x / maxy.y * P11);
	aabb = aabb.xwzy * vec4(0.5, -0.5, 0.5, -0.5) + vec4(0.5); // clip space -> uv space

	return true;
}

bool is_visible(uint index) {
    uint world_index = u_draw.data[index].first_instance;

    vec4 bsphere = u_world.data[world_index].bsphere;

   // mat4 transform = u_world.data[index].transform;
    //vec3 translation = vec3(transform[12], transform[13], transform[14]);
    vec4 world_center = u_world.data[world_index].transform * vec4(bsphere.xyz, 1.0);
    vec4 center = (u_main.view * vec4(world_center.xyz, 1.0));
    float radius = length((u_world.data[world_index].transform * vec4(bsphere.w, 0.0, 0.0, 0.0)).xyz);
  
    bool visible = true;

    visible = center.z * u_main.camera_frustum.y - abs(center.x) * u_main.camera_frustum.x > -radius &&
        center.z * u_main.camera_frustum.w - abs(center.y) * u_main.camera_frustum.z > -radius &&
        center.z > -s_camera_data.z - radius && center.z < s_camera_data.y + radius;
        
    visible = visible && (u_main.additional_info.y == 0 || u_occlusion.data[world_index] > 0);

    // center.z = -center.z;
   // center.y = -center.y;

   //center.y *= -1.0;

//    if (visible && u_main.additional_info.y > 0) {
//        vec4 aabb;
//        // if (project_sphere(center.xyz, radius, 0.5, u_main.proj[0][0], u_main.proj[1][1], aabb)) {
//		    float width = (aabb.z - aabb.x) * 1280.0; // cullData.pyramidWidth;
//		    float height = (aabb.w - aabb.y) * 720.0; // cullData.pyramidHeight;
//            float level = floor(log2(max(width, height))) + 1;
//            float depth = textureLod(u_depth_pyramid, (aabb.xy + aabb.zw) * 0.5, level).x;
//
//            depth = textureLod(u_depth_pyramid, (aabb.xy + aabb.zw) * 0.5, 0.0).x;
//
//            vec4 screenspace = u_main.proj * center;
//            screenspace.xyz /= screenspace.w;
//
//            depth = textureLod(u_depth_pyramid, screenspace.xy * 0.5 + 0.5, 4.0).x;
//
//		    //float depthSphere = s_camera_data.y / (center.z - radius);
//            //float depthSphere = 0.5 / (screenspace.z - radius);
//            //float depthSphere = center.z - radius;
//            float depthSphere = screenspace.z;// * 2.0 - 1.0;
//
//            visible = depthSphere < depth;
//        // }
//    }

    return visible;
}

void main() {
	uint index = uint(gl_GlobalInvocationID.x);
    
    if (index < u_main.additional_info.x) {
	    if (gl_LocalInvocationIndex == 0) {
            s_camera_data.x = 2.0 * atan(1.0 / u_main.proj[1][1]) * 180.0 / PI;
            s_camera_data.y = u_main.proj[3][2] / (u_main.proj[2][2] - 1.0);
            s_camera_data.z = u_main.proj[3][2] / (u_main.proj[2][2] + 1.0);
        }

        u_draw_output.data[index] = u_draw.data[index];
        
        if (u_draw.data[index].instance_count > 0 && !is_visible(index)) {
            u_draw_output.data[index].instance_count = 0;
        }
    }
}
